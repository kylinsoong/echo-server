= BANCS
:toc: manual

== Install and Run

[source, bash]
.*Install on x86*
----
rpm -ivh ttcp-1.13-1.x86_64.rpm
----

[source, bash]
.*List installed files*
----
~]# rpm -ql ttcp
/etc/bancs.data
/etc/ttcp.conf
/usr/bin/bancs
/usr/bin/chat
/usr/bin/echoS
/usr/bin/ttcp
----

=== 1:1 on 2 x86

There are 2 x86 servers on for BANCS, another for CARD, use default ports pair(8805/8806). 

[source, bash]
.*1. Start CARD*
----
bancs -c 10.1.20.203
----

[source, bash]
.*2. Start BANCS*
----
bancs -b 10.1.10.205
----

NOTE: `10.1.10.205` is the host to run CARD, `10.1.20.203` is the host to run BANCS.

[source, bash]
.*3. verify setring up*
----
// process on BANCS
~]# ps -ef | grep bancs
root       1621   1557  0 11:00 pts/0    00:00:00 bancs -b 10.1.10.205
root       1622   1621  0 11:00 pts/0    00:00:00 bancs -b 10.1.10.205

// tcp connections on BANCS
~]# netstat -antulop | grep bancs
tcp        0      0 0.0.0.0:8805            0.0.0.0:*               LISTEN      1621/bancs           off (0.00/0/0)
tcp        0      0 0.0.0.0:9805            0.0.0.0:*               LISTEN      1622/bancs           off (0.00/0/0)
tcp        0      0 10.1.20.203:8805        10.1.20.1:50665         ESTABLISHED 1621/bancs           off (0.00/0/0)
tcp        0      0 10.1.20.203:37820       10.1.10.205:8806        ESTABLISHED 1622/bancs           off (0.00/0/0)

// process on CARD
~]# ps -ef | grep bancs
root       3846   1227  0 10:59 pts/1    00:00:00 bancs -c 10.1.20.203

// tcp connections on CARD
~]# netstat -antulop | grep bancs
tcp        0      0 0.0.0.0:8806            0.0.0.0:*               LISTEN      3846/bancs           off (0.00/0/0)
tcp        0      0 10.1.10.205:56124       10.1.20.203:8805        ESTABLISHED 3846/bancs           off (0.00/0/0)
tcp        0      0 10.1.10.205:8806        10.1.10.1:50659         ESTABLISHED 3846/bancs           off (0.00/0/0)
----

[source, bash]
.*4. Test*
----
// send a message to BANCS which simulate a banks transaction from channel system like Mobile Bank app.
~]# bancs -e 10.1.20.203
25-Sep-2022 11:11:45 (3876) CLIENT: connect to bancs 10.1.20.203
25-Sep-2022 11:11:45 (3876) CLIENT: send message to bancs
25-Sep-2022 11:11:45 (3876) CLIENT: message: 2d313131363030303030313737303032343136393638..
25-Sep-2022 11:11:45 (3876) CLIENT: exit

// BANCS handle banks transaction, send request message to CARD
25-Sep-2022 11:11:45 (1622) BANCS: inbound message from 10.1.20.1:51280, request message to card, message: 2d31313136303030303031373730303234313639363..

// CARD process, and send response message to BANCS
25-Sep-2022 11:11:45 (3846) CARD: receive request message from bancs: 2d313131363030303030313737303032343136393638303937303030303...
25-Sep-2022 11:11:45 (3846) CARD: response message to bancs, message: 2d313131363030303030313737303032343136393638303937303030303...

// BANCS receive response from CARD
25-Sep-2022 11:11:45 (1621) BANCS: response message from card, message: 2d31313136303030303031373730303234313639363830393730303030303030...
----

== BIG-IP sit between BANCS and CARD

=== Generic Message

The Message Routing Framework (MRF) is an extension to the BIG-IP system to support routing of messages between connections. MRF is a protocol independent framework that is used to build protocol specific routing systems. Currently three protocol implementation of MRF are supported by the BIG-IP system: DIAMETER, SIP and Generic Message.

The Generic Message implementation of MRF provides a series of iRule commands for generating and populating a message. A message container wraps data that will be routed between connections. Associated with the message are meta-data fields used to assist routing of the message.

Generic Message has 3 types of message:

* *Request Message* - Request messages are messages that expect a response to be returned from the destination. A request message contains payload data and a source and destination address. The source address will be auto populated by Generic Message with the peer name of the originating connection. The destination address will need to be populated by the script. The source and destination address will be used by the route table to find the best matching route to use for delivering the message. Setting the destination address of a message will identify the message as a request message. The destination address is often generated by data contained in the message.
* *Response Message* - Response messages are messages returned by the destination to be delivered to the originator of the request. A message without a destination address is assumed to be a response message.Generic message will assign a request-sequence-number to all request messages before raising GENERICMESSAGE_EGRESS event. The details of the originating flow (TMM and flow_id) of the request will be stored in a pending request table on the outgoing connection. Each response message is initially assigned the oldest request-sequence-number in the pending request queue before raising GENERICMESSAGE_INGRESS event. Upon completion of the event the message will be forward to stored connection from the pending request table using the request-sequence-number. If the pending request table is empty, the response message will be routed via the route table. The default response routing implementation assumes that responses will arrive in the order that the requests were forwarded. If response message can arrive out of order, the script author will need to set the appropriate request-sequence-number during GENERICMESSAGE_INGRESS event.
* *Notification Message* - Notification messages are messages that do not expect a response. Setting the no-response attribute of the message will instruct generic message that no response is expected for the message. If all messages will be notification message, the no-response attribute in the protocol profile should be set to 'yes'.

Generic Message has 2 type of event:

* *GENERICMESSAGE_INGRESS* - This event is raised when a message is received by the generic message filter.
* *GENERICMESSAGE_EGRESS* - The event is raised when a message is received from the proxy.

Generic Message Commands

* `GENERICMESSAGE::peer name` - Gets the peer's route name.
* `GENERICMESSAGE::peer name <name>` - Sets the peer's route name.
* `GENERICMESSAGE::message src` - Gets the message's source address
* `GENERICMESSAGE::message src <src_addr>` - Sets the message's source address
* `GENERICMESSAGE::message dst` - Gets the message's destination address
* `GENERICMESSAGE::message dst <dst_addr>` - Sets the message's destination address
* `GENERICMESSAGE::message is_request` - Returns `true` if the message is a request message
* `GENERICMESSAGE::message is_request true OR false` - Identifies the message as a request
* `GENERICMESSAGE::message length` - Gets the message size in bytes.
* `GENERICMESSAGE::message text` - Gets the message text.
* `GENERICMESSAGE::message text <new_text>` - Sets the message text.
* `GENERICMESSAGE::message data` - Gets the message data (as an array of bytes).
* `GENERICMESSAGE::message data <new_data>` - Sets the message data (as an array of bytes).
* `GENERICMESSAGE::message no-response` - Returns 'true' if the message is an asynchronous message.
* `GENERICMESSAGE::message no_response true OR false` - Identifies the message as an asynchronous message.
* `GENERICMESSAGE::message create [<text> [<destination address>]]` - Creates a new empty message that can be sent. Once created a TEXTMSG_INGRESS event shall be raised where the script writer will be able to populate the message. Upon completion of the script, the message will be forwarded for routing.
* `GENERICMESSAGE::message drop <reason>` - Terminates processing of the current message.
* `GENERICMESSAGE::message status` - Returns the route status. Please see MR::message status
* `GENERICMESSAGE::message request_sequence_number` - Gets the request_sequence_number used to save the last hop of a request message. This will be valid during GENERICMESSAGE_EGRESS of request messages. During GENERICMESSAGE_INGRESS of response messages, it will contain the sequence number of the oldest un-responded request.
* `GENERICMESSAGE::message request_sequence_number <number>` - Sets the request_sequence_number used to save the last hop of a request message. During GENERICMESSAGE_INGRESS, setting this field will allow associting a response message with an un-responded request message and the request message's lasthop will be used as the next hop for the message.
* `GENERICMESSAGE::route add [src <src_addr>] [dst <dst_addr>] peer <peer> [peer <peer>]*` - Adds a route to the current instance that the iRule context is running in. (Note both 'src' and 'source' are acceptable. Likewise 'dst', 'dest' and 'destination' are acceptable). 
* `GENERICMESSAGE::route delete [src <src_addr>] [dst <dst_addr>]` - Deletes a route from the current instance that the iRule context is running in. (Note both 'src' and 'source' are acceptable. Likewise 'dst', 'dest' and 'destination' are acceptable).
* `GENERICMESSAGE::route lookup [src <src_addr>] [dst <dst_addr>]` - Returns a route matching the specified source address and destination address in the instance that the iRule context is running in. (Note both 'src' and 'source' are acceptable. Likewise 'dst', 'dest' and 'destination' are acceptable).

[source, bash]
.*Generic Message*
----
create ltm message-routing generic protocol protocol_bancs_card { app-service none disable-parser yes }
----

=== Transport Config

A transport config defines the parameters of a new outgoing connection. It is a subset of a virtual server used to define parameters of an outgoing connection. This includes the profiles, iRules and source-address-translation settings.

Since a transport-config may be used in a route that may be used in multiple router instances, the router profile is not defined in a transport-config object. Instead, an outgoing connection inherits the router profile of the router instance that creates an outgoing connection.

[source, bash]
.*Transport Config*
----
create ltm message-routing generic transport-config tc_bancs_card { profiles add { tcp-bancs { } protocol_bancs_card { } } rules { IRULES_BANCS_TO_CARD } }
----

=== Peer

A peer object is used to define a set of hosts and the the method to connect with them. Peers are used to create static routes. The peer structure is protocol independent while each protocol implementation of MRF will define its own static route structure.

If a transport-config is not defined, the outgoing connection will use the settings of the incoming connection for creating the outgoing connection.

If a pool is not defined, the outgoing connection will use the destination (local address) of the incoming connection as the destination (remote address) of the outgoing connection. 

If a pool with no pool members is used, the message routed to that peer will fail routing. 

Each connection is assigned a peer name. This peer name must be set via the GENERICMESSAGE::peer name iRule command. Once the peer name has been sent, the connection is able to receive and forward messages.

The peer name is used to add a dynamic route to the route table. It is also used to set the source address of each message.

[source, bash]
.*POOL_BANCS_TO_CARD*
----
create ltm pool POOL_BANCS_TO_CARD members add { 10.1.10.205:8806 { address 10.1.10.205 } } monitor tcp_half_open 
----

[source, bash]
.*POOL_BANCS_FROM_CARD*
----
create ltm pool POOL_BANCS_FROM_CARD members add { 10.1.20.203:8805 { address 10.1.20.203 } } monitor tcp_half_open 
----

[source, bash]
.*peer_BANCS_TO_CARD*
----
create ltm message-routing generic peer peer_BANCS_TO_CARD { pool POOL_BANCS_TO_CARD transport-config tc_bancs_card } 
----

[source, bash]
.*peer_BANCS_FROM_CARD*
----
create ltm message-routing generic peer peer_BANCS_FROM_CARD { pool POOL_BANCS_FROM_CARD transport-config tc_bancs_card } 
----

=== Route

Setting the route attribute of a message on ingress will bypass route table lookup and direct the router to forward the message directly to the route specified in the message. After routing has completed, the route attribute of the message will be populated with the details of the route used.

Generic message maintains a route table per router instance. The route table contains three types of routes, static routes from configuration, dynamic routes auto generated from peer names per connection and dynamic routes added by an iRule.

The route table will use the source and destination address of a message to determine the best matching route to use for forwarding the message. The source and destination attributes of the route will be matched against the source and destination addresses of the route to generate a score. The highest scoring route is used for forwarding the message.

Generic message allows for static routes to be loaded from configuration. A static route contains a list of peers, where each peer contains a list transport-config and a pool.

A standard LTM pool is used to list a set of devices that messages may be routed towards.

[source, bash]
.*route_BANCS_TO_CARD*
----
create ltm message-routing generic route route_BANCS_TO_CARD { destination-address my_dest peers { peer_BANCS_TO_CARD } }
----

[source, bash]
.*route_BANCS_FROM_CARD*
----
create ltm message-routing generic route route_BANCS_FROM_CARD { destination-address my_dest peers { peer_BANCS_FROM_CARD } } 
----

=== Router Profile

A router profile configures the message router instance. All virtuals sharing the same router profile will share the same message router instance. They will be able to route message between the connections of all virtual in the same router instance. They will also share the same route table. The name of the router profile will be the name of the router instance.

[source, bash]
.*router_BANCS_TO_CARD*
----
create ltm message-routing generic router router_BANCS_TO_CARD { app-service none routes add { route_BANCS_TO_CARD } traffic-group traffic-group-1 }
----

[source, bash]
.*router_BANCS_FROM_CARD*
----
create ltm message-routing generic router router_BANCS_FROM_CARD { app-service none routes add { route_BANCS_FROM_CARD } traffic-group traffic-group-1 }
----

=== Virtual Server

A virtual server is a traffic-management object on the BIG-IP system that is represented by an IP address and a service. Clients on an external network can send application traffic to a virtual server, which then directs the traffic according to configuration instructions.

All virtuals sharing the same router profile will share the same router instance. This means that they will be able to use connections created by traffic on other virtuals. They will also be able to route message between each other.

The virtual server configuration contains a destination address and mask which specifies what IP addresses and port the virtual server will listen for incoming packets. The virtual server object also contains a source address allowing it to limit packets to those packets that originate from a range of devices.

The behavior of a virtual server is determined by the set of profiles attached to the virtual server. In addition, the behavior of a virtual can further be extended by assigning iRules to the virtual. Furthermore, *the transport-config object is used to define the outgoing connection*, for example source address translation, and translation modes of the virtual server. *Note, the virtual server configuration (e.g. pool and persistence profile) used to select a destination is not used in MRF*.

[source, bash]
.*VS_BANCS_TO_CARD*
----
create ltm virtual VS_BANCS_TO_CARD { destination 10.1.10.31:8806 ip-protocol tcp pool POOL_BANCS_TO_CARD profiles add { protocol_bancs_card { } router_BANCS_TO_CARD { } tcp-bancs { } } rules { IRULES_BANCS_TO_CARD } } 
----

[source, bash]
.*VS_BANCS_FROM_CARD*
----
create ltm virtual VS_BANCS_FROM_CARD { destination 10.1.10.31:8805 ip-protocol tcp pool POOL_BANCS_FROM_CARD profiles add { protocol_bancs_card { } router_BANCS_FROM_CARD { } tcp-bancs { } } rules { IRULES_BANCS_FROM_CARD } } 
----

=== iRule

==== New Connections

When a new connection is created, the iRule will need to set the peer name for the connection.

Each message will automatically have the source-address field populated with this peer name. A dynamic route will be entered for this connection with the assigned peer name used as the destination-address of the route. If a route already exists with the peer name, the earlier route will take precedence.

==== Message Creation

The data stream will need to be parsed during CLIENT_DATA and SERVER_DATA iRule events for messages. Once the bytes of a message has been collected, a message object will need to be created and populated.

The GENERICMESSAGE::message create command is used to create and populate a message.

Once a message is created, the GENERICMESSAGE_INGRESS event will be raised and the script author may modify and the message.

Upon completion of the GENERMESSAGE_INGRESS event, the message will be forwarded to the router for routing.

==== Message Routing

When a message is received for routing, MRF will raise the MR_INGRESS event. The script author may set the nexthop or route attribute of the message to bypass the normal route table lookup. Response messages may already have the nexthop attribute set but the protocol if a pending request existed in the table.

Upon completion of the MR_INGRESS event, fi the message's nexthop attribute is set, the message will be forwarded to the connection specified in the nexthop attribute.

* If the message's route attribute is set, route lookup will be skipped and the route value specified in the message's route attribute will be use to determine the distination host of for the message.
* If the message's route attribute is not set, the route lookup will be performed using the message's source and destination address. The message's route attribute will be populated with the selected route's value.

After route selection, a peer from the route value will be selected and a pool member will be selected from the selected peer.

* If available connection exists to the selected pool member, the message will be forwarded using that connection.
* If an available connection does not exist, a new connection will be created.

The MR_EGRESS event will be raised as the message is leaving the router to be forwarded to the destination.

If a route could not be found or a connection could not be created, a MR_FAILED event will be raised. The script author may attempt to retry routing using the MR::retry command.

==== Message Delivery

When the outgoing message is received by the protocol a GENERICMESSAGE_EGRESS event will be raised.  If the protocol's parser is disabled, the script author will need to output the data of the message in the script. 

*TCP::respond [GENERICMESSAGE::message data]*

==== MRF Events

* *MR_INGRESS* - This event is raised when a message is received by the message proxy and before a route lookup occurs. Setting the route for a message will bypass route lookup.
* *MR_EGRESS* - This event is raised after the route has been selected and processed and the message is delivered to the mr_proxy for forwarding on the new connflow.
* *MR_FAILED* - This event is raised when a message has been returned to the originating flow due to a routing failure.

==== MRF Commands

https://techdocs.f5.com/en-us/bigip-15-1-0/big-ip-service-provider-generic-message-administration/how-to-use-generic-message-irules/how-to-use-generic-message-irules/mrf-irule-events-and-commands/mrf-commands.html


